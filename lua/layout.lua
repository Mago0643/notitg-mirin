--- Generated by a script
---@diagnostic disable: undefined-global, lowercase-global

-- variables
--Player Combo Proxy
PC = {}
--Player Judgment Proxy
PJ = {}
--Player Proxy
PP = {}
P1 = {}
P2 = {}
P3 = {}
P4 = {}
P5 = {}
P6 = {}
P7  = {}
P8 = {}
--Player Table
P = {}

--functions

---```lua
---setdefault {percent, mod}
---```
---Sets the default value of the mod, which affects the initial value, and what value reset will set the mod to. Unlike set, this function cannot take a player number, and must apply to all players.
---
---`setdefault` should be used to set the value of mods that are expected to stay on the entire file, even through `resets`.
---```lua
----- sets 5x for this modfile
---setdefault {5, 'xmod'}
---
----- sets a default value for a bunch of mods
---setdefault {2, 'xmod', 100, 'dizzyholds', 100, 'stealthtype', 100, 'stealthpastreceptors', 100, 'reversetype', 100, 'modtimer'}
---```
---`setdefault` can also be used for user-created mods.
---```lua
----- create a mod that adjusts the zoom of the background
---definemod {'backgroundzoom', function(z)
---    backgroundsprite:zoom(z / 100)
---end}
----- by default, the background should have a default zoom of 100%
---setdefault {100, 'backgroundzoom'}
---```
function setdefault(percent, mods) end ---@type unknown
---```lua
---set {beat, percent, mod}
---```
---Use the `set` function to set a mod to a specific value at a specific beat in the song.
---
---The `set` function can also take more than one percent/mod at a time.
---
---The `set` function can also be [**player specific**](https://xerool.github.io/notitg-mirin/docs/players.html).
---@param beat number The song beat when the mod applies.
---@param percent number The target amount to set the mod to.
---@param mod string The mod to apply.
function set(beat, percent, mod) end ---@type unknown
---```lua
---ease {beat, len, ease_fn, percent, mod}
---```
---Use the `ease` function to animate a mod to a specific value at a specific beat in the song. The animation lasts `len` beats, and animates using the selected `ease_fn`.
---
---`ease` can also be [**player specific**](https://xerool.github.io/notitg-mirin/docs/players.html).
---@param beat number The song beat when the mod begins to apply.
---@param len number The amount of beats before the ease is complete.
---@param ease_fn function The way to approach the target value.
---@param percent number The target amount to set the mod to.
---@param mod string The mod to apply.
function ease(beat, len, ease_fn, percent, mod) end ---@type unknown
---```lua
---add {beat, len, ease_fn, relative_percent, mod}
---```
---The `add` function works like `ease`, except it is relative. The `add` function will add to the old value of the mod instead of overriding the old value of the mod with a new value. So, for example, if a mod is currently at `200`, and an `add` runs with the value of `100`, the result would be `300`.
---
---`add` can also be [**player specific**](https://xerool.github.io/notitg-mirin/docs/players.html).
---@param beat number The song beat when the mod begins to apply.
---@param len number The amount of beats before the ease is complete.
---@param ease_fn function The way to approach the target value.
---@param percent number The amount to add to the mod.
---@param mod string The mod to apply.
function add(beat, len, ease_fn, percent, mod) end ---@type unknown
---```lua
---func {beat, function(b)}
---```
---The `func` function is used to run code at certain beats in the song.
---```lua
----- writes 'hello world' to screen on beat 64
---func {64, function()
---    SCREENMAN:SystemMessage('hello world')
---end}
---
----- hides P1 on beat 32
---func {32, function()
---    P1:hidden(1)
---end}
---```
---The given function will run at the given beat.
---@param beat number The song beat when the function should run.
---@param fn function The function to run.
function func(beat, fn) end ---@type unknown
---```lua
---func_ease {beat, len, ease_fn, function(p)}
---func_ease {beat, len, ease_fn, percent, function(p)}
---func_ease {beat, len, ease_fn, begin_percent, end_percent, function(p)}
---func_ease {beat, len, ease_fn, percent, 'actor:method'}
---func_ease {beat, len, ease_fn, begin_percent, end_percent, 'actor:method'}
---```
---The `func_ease` function is used to animate a function using an ease, by calling the inner function every frame with a number that changes each frame according to the ease. This function can be used in order to animate things other than mods. Use `ease` to animate mods.
---
---The given function will get called repeatedly. The function will recieve a number, `p`, which represents the progress though the effect. `p` will range from the `start_percent` to the `end_percent` according to the given ease function.
---```lua
---func_ease {0, 4, outExpo, 360, 0, function(p)
---    P1:rotationz(p)
---end}
---```
---In this example, the player is being rotated using the `:rotationz` method instead of with the `rotationz` mod.
---@param beat number The song beat when the function should begin being called.
---@param len number The length of beats when the function should be called.
---@param ease_fn function The ease to use.
---@param start_percent number|nil The starting value to pass to the function, or 0 by default.
---@param target_percent number|nil The final value to pass to the function, or 1 by default.
---@param fn string|function The function to run for every frame of the effect.
function func_ease(beat, len, ease_fn, start_percent, target_percent, fn) end ---@type unknown
---```lua
---perframe {beat, len, function(b, poptions)}
---```
---The given function will be called every frame within the range.
---
---The `perframe` function runs the function on every single frame starting at the `beat`. It lasts for `len` beats. The inner function is given the current beat, and also the [poptions](https://xerool.github.io/notitg-mirin/docs/func.html#poptions) table which can be used to read/write the state of the mods.
---@param beat number The song beat when the function should begin being called.
---@param len number The length of beats when the function should be called.
---@param fn function The function to run every frame in the range.
function perframe(beat, len, fn) end ---@type unknown

-- god damn i never seen before like this

---```lua
---node {modname, function(p)
---    -- code
---end}
---
----- alternatively
---node {
---     modname,
---         function(p)
---                 --code
---                 return k
---         end,
---     modname_out
---}
---```
---`node` creates a function that transforms the values of mods before they are applied every frame. node creates a function that takes in mod values and outputs mod values.
---
---## Examples
--------------------------------------------------
---#### Blacksphere
---This example shows how to create a `'blacksphere'` mod with node.
---```lua
---aux {'blacksphere'}
---node {
---     'blacksphere',
---     function(blacksphere)
---         local invert = 50 - 50 * math.cos(blacksphere * math.pi / 180)
---         local alternate = 25 * math.sin(blacksphere * math.pi / 180)
---         local reverse = -12.5 * math.sin(blacksphere * math.pi / 180)
---         return invert, alternate, reverse
---     end,
---     'invert', 'alternate', 'reverse',
---}
---```
---Firstly, the `aux` function marks the mod `'blacksphere'` as an auxiliary mod. Then, the node function reads the value stored in `'blacksphere'`, and calculates and returns the amount of `'invert'`, `'alternate'`, and `'reverse'` to apply.
---
---Then, the `'blacksphere'` auxiliary mod can be used:
---```lua
---ease {0, 1, outExpo, 180, 'blacksphere'}
---ease {4, 1, outExpo, 0, 'blacksphere'}
---```
---Although `'blacksphere'` uses `'invert'`, `'alternate'`, and `'reverse'`, those mods can still be used.
---```lua
---ease {0, 10, linear, 360, 'blacksphere', 100, 'reverse'}
---```
---------------------------------------
---#### Rotate BG
---`node` can be used to bind properties of actors to auxiliary mods. In this example, the mod `'rotatebg'` is is set up to control the angle of an actor.
---```lua
----- In the Lua
---aux {'rotatebg'}
---node {'rotatebg', function(p)
---     my_bg_actor:rotationz(p)
---end}
---
----- In the XML
---```
---```xml
---<Layer Name = "my_bg_actor" File = "my_background_file.png">
---```
---Then, the `'rotatebg'` mod controls the rotation of the actor.
---
----------------------------------------
---#### Tornado scaled by Flip
---If a node reads and writes to the same mod, then that mod is overwritten instead of added.
---```lua
---node {
---     'flip', 'tornado',
---     function(flip, tornado)
---         return (1 - flip * 0.02) * tornado
---     end,
---     'tornado',
---}
---```
-----------------------------------------
---#### Superpowered Counter Rotation
---Here’s an example of how powerful `node` can be: This node makes the confusionoffset mods be independent of the rotation mods.
---```lua
---alias {'confusionzoffset', 'confusionoffset'}
---local sin, cos = math.sin, math.cos
---local asin, atan2 = math.asin, math.atan2
---local pi = math.pi
---node {
---     'rotationx', 'rotationy', 'rotationz',
---     'confusionxoffset', 'confusionyoffset', 'confusionoffset',
---     function(rx, ry, rz, cx, cy, cz)
---         -- transform axes
---         rx, rz = rz, rx
---         cx, cz = cz, cx
---
---         -- helpers for r
---         local rcosx, rcosy, rcosz, rsinx, rsiny, rsinz =
---         cos(rx / 360 * pi), cos(ry / 360 * pi), cos(rz / 360 * pi),
---         sin(rx / 360 * pi), sin(ry / 360 * pi), sin(rz / 360 * pi)
---
---         -- r to quaternion
---         local ra, rb, rc, rd =
---         rcosx*rcosy*rcosz-rsinx*rsiny*rsinz,
---         rsinx*rsiny*rcosz+rcosx*rcosy*rsinz,
---         rsinx*rcosy*rcosz+rcosx*rsiny*rsinz,
---         rcosx*rsiny*rcosz-rsinx*rcosy*rsinz
---
---         -- helpers for c
---         local ccosx, ccosy, ccosz, csinx, csiny, csinz =
---         cos(cx/200), cos(cy/200), cos(cz/200),
---         sin(cx/200), sin(cy/200), sin(cz/200)
---
---         -- c to quaternion
---         local ca, cb, cc, cd =
---         ccosx*ccosy*ccosz-csinx*csiny*csinz,
---         csinx*csiny*ccosz+ccosx*ccosy*csinz,
---         csinx*ccosy*ccosz+ccosx*csiny*csinz,
---         ccosx*csiny*ccosz-csinx*ccosy*csinz
---
---         -- o = c * inverse(r)
---         local oa, ob, oc, od =
---         ca*ra+cb*rb+cc*rc+cd*rd,
---         -ca*rb+cb*ra-cc*rd+cd*rc,
---         -ca*rc+cb*rd+cc*ra-cd*rb,
---         -ca*rd-cb*rc+cc*rb+cd*ra
---
---         -- o to euler angles
---          local ox, oy, oz =
---         100 * atan2(2*oc*oa-2*ob*od, 1-2*oc*oc-2*od*od),
---         100 * asin(2*ob*oc+2*od*oa),
---         100 * atan2(2*ob*oa-2*oc*od, 1-2*ob*ob-2*od*od)
---
---         -- transform axes
---         ox, oz = oz, ox
---         return ox, oy, oz
---     end,
---'confusionxoffset', 'confusionyoffset', 'confusionoffset',
---}
---```
---@param modname string The mods to take as input to the function
---@param func function The function to run.
---@param modname_out nil|string The name of the mods to write back to.
function node(modname, func, modname_out) end ---@type unknown
---```lua
---aux {modname}
---```
---The `aux` function creates an auxiliary mod. The template will keep track of the value of the mod, but will not apply it to the players.
---```lua
---aux {'blacksphere'}
---aux {'my_mod_1'}
---```
---The `aux` function can also take more than one modname.
---```lua
---aux {'mod1', 'mod2', 'mod3'}
---```
---@param modname string The name of the mod to create.
function aux(modname) end ---@type unknown
---```lua
---definemod {modname, function(percent)
---     -- implementation
---end}
---```
---The function `definemod` can be used to define custom auxiliary mods. Whenever `modname` is eased, the callback function will be called with the updated `percent`. `definemod` is useful because it lets the ease engine be used to control arbitrary non-mod behavior.
---```lua
---definemod {'rotatebg', function(p)
---     -- rotates the actor `my_bg_actor`
---     my_bg_actor:rotationz(p)
---end}
---```
---This example ties the angle of an actor to a mod named `'rotatebg'`.
---
-------------------------------------------------
---### Multiple Mods
---```lua
---definemod {mod1, mod2, mod3, ..., function(mod1, mod2, mod3, ...)
---     -- implementation
---end}
---```
---If an implementation needs to access multiple ease values simultaneously, then multiple mods can be listed. The function arguments match the order that the mods are listed.
---```lua
---definemod {'actorradius', 'actorangle', function(r, a)
---     my_actor:xy(math.cos(a) * r, math.sin(a) * r)
---end}
---```
---This example moves an actor using multiple input mods simultaneously.
---
----------------------------------------------------
---### Player Specific
---```lua
---definemod {mymod, function(percent, pn)
---     -- implementation
---end}
---```
---Although it is rare, there are sometimes cases when a defined mod to be player specific: ie, it behaves differently depending on which player it’s been applied to. To accomplish this, the callback function can take in an extra argument, which is the player number.
---
-----------------------------------------------------
---### Write to Mods
---Sometimes, mod definitions need to write back to other mods. This can be done by adding return values to the function. Here’s an example that implements `blacksphere` in terms of `invert`, `alternate`, and `reverse`.
---```lua
---definemod {
---     'blacksphere',
---     function(blacksphere)
---         local invert = 50 - 50 * math.cos(blacksphere * math.pi / 180)
---         local alternate = 25 * math.sin(blacksphere * math.pi / 180)
---         local reverse = -12.5 * math.sin(blacksphere * math.pi / 180)
---         return invert, alternate, reverse
---     end,
---     'invert', 'alternate', 'reverse',
---}
---```
---@param modname string The name of the mod to define
---@param fn function the function that is called every time the mod is changed
function definemod(modname, fn) end ---@type unknown
---```lua
---reset {beat}
---reset {beat, len, eas}
---reset {beat, exclude = {mod1, mod2, mod3, ...}}
---```
---It resets all mods to their default value at the specified beat. If exclude is provided, it will not reset any of the mods in the list.
---
---See the [**setdefault**](https://xerool.github.io/notitg-mirin/docs/setdefault.html) page for more information on how to change the default value of a mod.
---```lua
----- reset the mods at beat 128
---reset {128}
---
----- reset the mods at beat 192, but keep 'reverse' and 'alternate' on
---reset {128, exclude = {'reverse', 'alternate'}}
---
----- reset the mods at beat 256 with an ease, but keep 'spiralx' on
---reset {256, 1, outExpo, exclude = 'spiralx'}
---```
function reset(beat, len, ease, exclude) end ---@type unknown
---```lua
---alias {'oldmodname', 'newmodname'}
---```
---The `alias` function tells the game to treat two different mod names as the same mod name. The game will internally use the second provided name.
---```lua
---alias {'confusionzoffset', 'confusionoffset'}
---```
---@param oldmodname string The name of the mod to rename.
---@param newmodname string The new name of the mod.
function alias(oldmodname, newmodname) end ---@type unknown
---The flip function takes in an ease and returns a flipped version of that ease.
---```lua
---ease {4, 1, flip(outExpo), -200, 'tiny'}
---ease {8, 1, flip(outBounce), -50, 'flip'}
---```
function flip(ease) end ---@type unknown

bg = {}

--add your code.